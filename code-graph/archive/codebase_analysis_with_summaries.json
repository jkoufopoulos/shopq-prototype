{
  "metadata": {
    "generated": "2025-10-22T03:06:59.654558",
    "root_dir": "/Users/justinkoufopoulos/Projects/mailq-prototype"
  },
  "files": {
    "mailq/mapper.py": {
      "type": "python",
      "path": "mailq/mapper.py",
      "lines": 120,
      "docstring": "Gmail label mapper - converts semantic classification to Gmail label strings\nMulti-dimensional: each dimension gets its own label",
      "imports": [
        "typing.Dict",
        "typing.List",
        "typing.Any"
      ],
      "internal_imports": [],
      "external_imports": [
        "typing.Dict",
        "typing.List",
        "typing.Any"
      ],
      "classes": [],
      "functions": [
        {
          "name": "map_to_gmail_labels",
          "docstring": "Map semantic classification to Gmail labels (multi-dimensional).\nEach dimension gets separate labels."
        },
        {
          "name": "validate_classification_result",
          "docstring": "Validate classification result matches schema"
        }
      ],
      "complexity": 2,
      "content_hash": "bded52690d62adc8d55d60a923e876ffcebd6fef5ffeb5a114d488c3993a65f1",
      "ai_summary": "SUMMARY: This file is a utility that converts semantic email classification results, encompassing dimensions like type, domain, and attention, into a structured list of Gmail label strings based on defined confidence thresholds.\n\nRELATIONSHIPS: This file acts as a core mapping utility, primarily imported and used by `mailq/memory_classifier.py`. It takes the raw classification output from `memory_classifier.py` and transforms it into an actionable format suitable for applying Gmail labels. Its role is to bridge the internal semantic classification logic with the external mechanism of organizing emails through labels."
    },
    "mailq/feedback_manager.py": {
      "type": "python",
      "path": "mailq/feedback_manager.py",
      "lines": 365,
      "docstring": "Feedback management for user corrections.\nStores corrections and learns patterns for improved classification.",
      "imports": [
        "sqlite3",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "datetime.datetime",
        "pathlib.Path",
        "json"
      ],
      "internal_imports": [],
      "external_imports": [
        "sqlite3",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "datetime.datetime",
        "pathlib.Path",
        "json"
      ],
      "classes": [
        {
          "name": "FeedbackManager",
          "methods": [
            "__init__",
            "_init_db",
            "record_correction",
            "_extract_type_from_labels",
            "_extract_domains_from_labels",
            "_learn_from_correction",
            "get_high_confidence_patterns",
            "get_correction_stats",
            "get_fewshot_examples",
            "get_top_corrected_senders",
            "get_recent_corrections"
          ],
          "method_count": 11,
          "docstring": ""
        }
      ],
      "functions": [],
      "complexity": 11,
      "content_hash": "d53fbeed0c1a9c823a05f98aad46b0e6248a44b85f9e12135ef456ad12902254",
      "ai_summary": "SUMMARY: The `FeedbackManager` class stores user corrections, learns classification patterns, and manages few-shot examples in a SQLite database to continuously improve the `mailq` system's email classification accuracy.\n\nRELATIONSHIPS: This file acts as a core data persistence layer, managing a SQLite database for feedback and learning. It depends on standard Python libraries like `sqlite3` for database interaction. Other components, specifically `mailq/api.py` and `mailq/api_feedback.py`, utilize this manager to store user corrections and retrieve learned patterns, while `mailq/vertex_gemini_classifier.py` likely fetches patterns and few-shot examples to enhance its AI-driven classification process."
    },
    "mailq/__init__.py": {
      "type": "python",
      "path": "mailq/__init__.py",
      "lines": 8,
      "docstring": "MailQ Production System",
      "imports": [
        "mailq.rules_engine.RulesEngine",
        "mailq.memory_classifier.MemoryClassifier"
      ],
      "internal_imports": [
        "mailq/rules_engine.py",
        "mailq/memory_classifier.py"
      ],
      "external_imports": [],
      "classes": [],
      "functions": [],
      "complexity": 0,
      "content_hash": "3261301d8a91da7ecfc79aabbc45b59d664a95b61eed56f6f5c1d294cd50420d",
      "ai_summary": "SUMMARY: This file initializes the MailQ package, exposing its core `RulesEngine` and `MemoryClassifier` components as part of its public API, and declares the package version.\n\nRELATIONSHIPS: This file acts as the primary public interface and package initializer for the `mailq` system. It directly depends on `mailq/rules_engine.py` and `mailq/memory_classifier.py`, importing their classes to make them accessible directly from the `mailq` package namespace. Other parts of the codebase that utilize MailQ's core logic will typically import these components via `from mailq import RulesEngine`, establishing this `__init__.py` as a central access point to the system's core functionalities."
    },
    "mailq/rules_manager.py": {
      "type": "python",
      "path": "mailq/rules_manager.py",
      "lines": 157,
      "docstring": "Rules Management Module\n\nHandles CRUD operations for classification rules:\n- Fetching rules from database\n- Adding new rules\n- Updating existing rules\n- Deleting rules",
      "imports": [
        "mailq.config.database.get_db_connection",
        "mailq.config.database.db_transaction",
        "typing.List",
        "typing.Dict",
        "typing.Optional"
      ],
      "internal_imports": [
        "mailq/config/database.py"
      ],
      "external_imports": [
        "typing.List",
        "typing.Dict",
        "typing.Optional"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_rules",
          "docstring": "Fetch all active rules for a user\n\nArgs:\n    user_id: User identifier (default: 'default')\n\nReturns:\n    List of rule dictionaries with pattern_type, pattern, category"
        },
        {
          "name": "add_rule",
          "docstring": "Add a new classification rule\n\nArgs:\n    pattern_type: Type of pattern ('from', 'subject', 'keyword')\n    pattern: The actual pattern to match\n    category: Category to assign (e.g., 'Finance', 'Promotions')\n    confidence: Confidence score (0-100)\n    user_id: User identifier\n\nReturns:\n    ID of the newly created rule\n\nRaises:\n    sqlite3.IntegrityError: If rule already exists (duplicate)"
        },
        {
          "name": "update_rule",
          "docstring": "Update an existing rule\n\nArgs:\n    rule_id: ID of rule to update\n    **kwargs: Fields to update (pattern, category, confidence, etc.)\n\nReturns:\n    True if rule was updated, False if not found"
        },
        {
          "name": "delete_rule",
          "docstring": "Delete a rule by ID\n\nArgs:\n    rule_id: ID of rule to delete\n\nReturns:\n    True if deleted, False if not found"
        },
        {
          "name": "get_rule_stats",
          "docstring": "Get statistics about rules\n\nReturns:\n    Dict with total_rules, by_type, by_category, etc."
        }
      ],
      "complexity": 5,
      "content_hash": "a103e72b54fea321d8229147a9d6eac01f722e03fd862c0a3d483fc1feacfe30",
      "ai_summary": "SUMMARY: This module manages email classification rules by providing functions for CRUD operations like fetching, adding, updating, and deleting rules stored in the database.\n\nRELATIONSHIPS: This file heavily depends on `mailq/config/database.py` to handle all its database connections and transactions for persistent storage of classification rules. It is imported and utilized by `mailq/api.py`, suggesting that the API layer exposes these rule management functionalities, making this file a core backend logic component for the system's rule-based email classification."
    },
    "mailq/logger.py": {
      "type": "python",
      "path": "mailq/logger.py",
      "lines": 21,
      "docstring": "Centralized logging - CREATE THIS FILE",
      "imports": [
        "logging",
        "sys"
      ],
      "internal_imports": [],
      "external_imports": [
        "logging",
        "sys"
      ],
      "classes": [],
      "functions": [
        {
          "name": "setup_logger",
          "docstring": ""
        }
      ],
      "complexity": 1,
      "content_hash": "8fb4c2e416892f947ed15deb971c8089ca4640fbd71ae0b5858a089df9821c63",
      "ai_summary": "SUMMARY: This file provides a utility function to centrally configure and return a standardized Python logger that outputs formatted messages to standard output, preventing duplicate handlers.\n\nRELATIONSHIPS: This file serves as a utility for centralized, consistent logging within the `mailq` application. It depends on Python's built-in `logging` and `sys` modules to configure loggers that output formatted messages to `sys.stdout`. Other components, such as `mailq/rules_engine.py`, import and use its `setup_logger` function to acquire these pre-configured loggers, ensuring uniform log output across the system."
    },
    "mailq/memory_classifier.py": {
      "type": "python",
      "path": "mailq/memory_classifier.py",
      "lines": 190,
      "docstring": "Memory-enhanced email classifier using rules + LLM with Vertex AI",
      "imports": [
        "os",
        "typing.Dict",
        "mailq.rules_engine.RulesEngine",
        "mailq.vertex_gemini_classifier.VertexGeminiClassifier",
        "mailq.mapper.map_to_gmail_labels",
        "mailq.mapper.validate_classification_result"
      ],
      "internal_imports": [
        "mailq/rules_engine.py",
        "mailq/vertex_gemini_classifier.py",
        "mailq/mapper.py"
      ],
      "external_imports": [
        "os",
        "typing.Dict"
      ],
      "classes": [
        {
          "name": "MemoryClassifier",
          "methods": [
            "__init__",
            "classify",
            "_rule_to_semantic",
            "_fallback_semantic",
            "get_stats"
          ],
          "method_count": 5,
          "docstring": ""
        }
      ],
      "functions": [],
      "complexity": 5,
      "content_hash": "3d5aec1c89a1bf9d18b6540a5aa6e6d37e4a1a18baf258b4fdaed69654e5369a",
      "ai_summary": "SUMMARY: This file provides a memory-enhanced email classifier that prioritizes rule-based classification, falling back to a Vertex AI Gemini LLM, and mapping results to Gmail labels.\n\nRELATIONSHIPS: This file acts as the core classification logic, orchestrating rule-based matching using `mailq.rules_engine` and leveraging `mailq.vertex_gemini_classifier` for LLM inference when rules don't match. It further depends on `mailq.mapper` for result transformation and validation, and is a foundational component directly consumed by `mailq/api.py` to expose the primary email classification functionality."
    },
    "mailq/api.py": {
      "type": "python",
      "path": "mailq/api.py",
      "lines": 300,
      "docstring": "FastAPI server for MailQ email classification",
      "imports": [
        "fastapi.FastAPI",
        "fastapi.HTTPException",
        "fastapi.middleware.cors.CORSMiddleware",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "time",
        "datetime.datetime",
        "mailq.memory_classifier.MemoryClassifier",
        "mailq.category_manager.CategoryManager",
        "mailq.feedback_manager.FeedbackManager",
        "mailq.rules_manager.get_rules",
        "mailq.rules_manager.add_rule",
        "mailq.rules_manager.update_rule",
        "mailq.rules_manager.delete_rule",
        "mailq.rules_manager.get_rule_stats",
        "mailq.api_debug.router",
        "mailq.api_debug.set_last_batch",
        "mailq.api_feedback.router",
        "mailq.api_feedback.set_feedback_manager",
        "mailq.api_organize.classify_batch",
        "uvicorn"
      ],
      "internal_imports": [
        "mailq/api_organize.py",
        "mailq/api_feedback.py",
        "mailq/memory_classifier.py",
        "mailq/api_debug.py",
        "mailq/rules_manager.py",
        "mailq/category_manager.py",
        "mailq/feedback_manager.py"
      ],
      "external_imports": [
        "fastapi.FastAPI",
        "fastapi.HTTPException",
        "fastapi.middleware.cors.CORSMiddleware",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "time",
        "datetime.datetime",
        "uvicorn"
      ],
      "classes": [
        {
          "name": "EmailInput",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "EmailBatch",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "ClassificationResult",
          "methods": [],
          "method_count": 0,
          "docstring": "Multi-dimensional classification result"
        },
        {
          "name": "OrganizeResponse",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "CategoryCreate",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "RuleCreate",
          "methods": [],
          "method_count": 0,
          "docstring": "Request model for creating a rule"
        },
        {
          "name": "RuleUpdate",
          "methods": [],
          "method_count": 0,
          "docstring": "Request model for updating a rule"
        },
        {
          "name": "Config",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "Config",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        }
      ],
      "functions": [
        {
          "name": "root",
          "docstring": ""
        },
        {
          "name": "health",
          "docstring": ""
        }
      ],
      "complexity": 2,
      "content_hash": "3149d306e634926d8d76d670bf6e78c28bf12b02222f85b32c3033a80f4a5804",
      "ai_summary": "SUMMARY: This file initializes the MailQ FastAPI server, orchestrating core services like email classification and feedback management, defining API models, and integrating specialized endpoint routers.\n\nRELATIONSHIPS: This file serves as the primary entry point and API layer for the MailQ application, setting up the FastAPI server and configuring global middleware. It instantiates and depends on `MemoryClassifier`, `CategoryManager`, and `FeedbackManager` for core email processing, passing these services as dependencies to integrated API routers from `mailq.api_debug` and `mailq.api_feedback`. This centralizes the instantiation and connection of various internal components to expose a comprehensive set of endpoints."
    },
    "mailq/api_feedback.py": {
      "type": "python",
      "path": "mailq/api_feedback.py",
      "lines": 97,
      "docstring": "Feedback API endpoints for user corrections",
      "imports": [
        "fastapi.APIRouter",
        "fastapi.HTTPException",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "mailq.feedback_manager.FeedbackManager",
        "mailq.api_dashboard.render_dashboard",
        "fastapi.responses.HTMLResponse"
      ],
      "internal_imports": [
        "mailq/api_dashboard.py",
        "mailq/feedback_manager.py"
      ],
      "external_imports": [
        "fastapi.APIRouter",
        "fastapi.HTTPException",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "fastapi.responses.HTMLResponse"
      ],
      "classes": [
        {
          "name": "FeedbackInput",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        },
        {
          "name": "Config",
          "methods": [],
          "method_count": 0,
          "docstring": ""
        }
      ],
      "functions": [
        {
          "name": "set_feedback_manager",
          "docstring": "Inject feedback manager instance"
        }
      ],
      "complexity": 1,
      "content_hash": "aed731c70464df112b5d55f124b609f0d9b25cc1f179bbe2e17e031ac09a61d8",
      "ai_summary": "SUMMARY: This file defines FastAPI endpoints for submitting user corrections on email classifications, retrieving learning statistics, and serving a feedback dashboard.\n\nRELATIONSHIPS: This file acts as an API layer, providing external access to the feedback system. It critically depends on `mailq.feedback_manager` for handling the core business logic of recording and querying feedback, and utilizes `mailq.api_dashboard` to render its HTML dashboard. The `mailq/api.py` module imports this file's `APIRouter` to integrate these endpoints into the main application, making it the primary interface for user interaction with the feedback mechanism."
    },
    "mailq/api_dashboard.py": {
      "type": "python",
      "path": "mailq/api_dashboard.py",
      "lines": 255,
      "docstring": "Dashboard HTML rendering for feedback visualization",
      "imports": [
        "datetime.datetime",
        "json",
        "typing.List",
        "typing.Dict"
      ],
      "internal_imports": [],
      "external_imports": [
        "datetime.datetime",
        "json",
        "typing.List",
        "typing.Dict"
      ],
      "classes": [],
      "functions": [
        {
          "name": "render_dashboard",
          "docstring": "Render feedback dashboard HTML"
        },
        {
          "name": "_get_dashboard_css",
          "docstring": "Dashboard CSS styles"
        },
        {
          "name": "_render_top_senders",
          "docstring": "Render top corrected senders"
        },
        {
          "name": "_render_patterns",
          "docstring": "Render high-confidence patterns ready for allowlist"
        },
        {
          "name": "_render_recent_corrections",
          "docstring": "Render recent corrections table"
        }
      ],
      "complexity": 5,
      "content_hash": "2a815f0c8c5b7f5ba59ef93fc02ad95835dfc1a4a6ebfb8174f0b16f8e61bace",
      "ai_summary": "SUMMARY: This file provides utility functions to dynamically render a comprehensive HTML dashboard for visualizing MailQ's feedback, including statistics, correction patterns, and recent activities, based on provided data.\n\nRELATIONSHIPS: This file acts as an HTML templating utility or presentation layer within the MailQ system. It is imported and utilized by `mailq/api_feedback.py`, which is likely an API endpoint responsible for gathering the necessary data and then calling `render_dashboard` to generate the HTML response for a web request. While it depends on standard Python libraries like `datetime` for formatting, it primarily relies on receiving structured data from other MailQ components (via `api_feedback.py`) to construct the visual dashboard."
    },
    "mailq/rules_engine.py": {
      "type": "python",
      "path": "mailq/rules_engine.py",
      "lines": 282,
      "docstring": "Rules-based email classification with learning",
      "imports": [
        "sqlite3",
        "os",
        "typing.Dict",
        "typing.List",
        "collections.Counter",
        "re",
        "mailq.logger.setup_logger"
      ],
      "internal_imports": [
        "mailq/logger.py"
      ],
      "external_imports": [
        "sqlite3",
        "os",
        "typing.Dict",
        "typing.List",
        "collections.Counter",
        "re"
      ],
      "classes": [
        {
          "name": "RulesEngine",
          "methods": [
            "__init__",
            "_init_db",
            "_extract_email_address",
            "_patterns_match",
            "classify",
            "get_matching_rules",
            "learn_from_classification",
            "_extract_keywords",
            "get_rule_count",
            "get_rules_for_category",
            "get_rule",
            "count",
            "learn_from_correction"
          ],
          "method_count": 13,
          "docstring": ""
        }
      ],
      "functions": [],
      "complexity": 13,
      "content_hash": "41a4a1f5edc65ec455e2fe23bedcfcd8a3cf5f16919f0df3ae6a56f306bf33f9",
      "ai_summary": "SUMMARY: This file implements a rules engine for email classification, storing user-defined and learned patterns in an SQLite database to categorize incoming messages based on various criteria.\n\nRELATIONSHIPS: This file relies on `mailq/logger.py` for standardized logging across the application. As a core logic component, it is imported by `mailq/__init__.py`, making its `RulesEngine` class a publicly accessible part of the `mailq` package. Additionally, `mailq/memory_classifier.py` imports this file, likely integrating its persistent, database-backed email classification rules into a broader classification strategy."
    },
    "mailq/api_organize.py": {
      "type": "python",
      "path": "mailq/api_organize.py",
      "lines": 175,
      "docstring": "Email classification logic for /api/organize endpoint",
      "imports": [
        "time",
        "traceback",
        "typing.List",
        "typing.Dict",
        "typing.Tuple"
      ],
      "internal_imports": [],
      "external_imports": [
        "time",
        "traceback",
        "typing.List",
        "typing.Dict",
        "typing.Tuple"
      ],
      "classes": [],
      "functions": [
        {
          "name": "classify_batch",
          "docstring": "Classify a batch of emails.\n\nReturns:\n    (results, stats) - Classification results and statistics"
        },
        {
          "name": "_update_stats",
          "docstring": "Update statistics counters"
        },
        {
          "name": "_filter_labels",
          "docstring": "Filter labels by confidence threshold"
        },
        {
          "name": "_print_low_confidence",
          "docstring": "Print low confidence warning"
        },
        {
          "name": "_print_classification",
          "docstring": "Print successful classification"
        },
        {
          "name": "_create_error_result",
          "docstring": "Create error result for failed classification"
        },
        {
          "name": "_print_summary",
          "docstring": "Print classification summary"
        }
      ],
      "complexity": 7,
      "content_hash": "6a2ca90068c3f094b76aac16931647380e2636309a80b6b2ae75d2011ebceaba",
      "ai_summary": "SUMMARY: This file provides core logic for classifying a batch of emails, applying confidence thresholds, filtering labels, and collecting statistics, primarily for the `/api/organize` API endpoint.\n\nRELATIONSHIPS: This file acts as a core logic component, specifically handling email classification for the `/api/organize` endpoint. It critically depends on an external `classifier` object (likely an AI model or rule engine) passed during runtime to perform the actual classification. The `mailq/api.py` module imports and utilizes the `classify_batch` function from this file, making it an essential backend processing layer for the Mailq API."
    },
    "mailq/api_debug.py": {
      "type": "python",
      "path": "mailq/api_debug.py",
      "lines": 93,
      "docstring": "Debug endpoints for monitoring classification batches",
      "imports": [
        "fastapi.APIRouter",
        "datetime.datetime",
        "typing.Dict",
        "typing.List"
      ],
      "internal_imports": [],
      "external_imports": [
        "fastapi.APIRouter",
        "datetime.datetime",
        "typing.Dict",
        "typing.List"
      ],
      "classes": [],
      "functions": [
        {
          "name": "set_last_batch",
          "docstring": "Update last batch (called from main app)"
        }
      ],
      "complexity": 1,
      "content_hash": "c0217d0eaff6dd1c9f9a9b4148a9e79e20b83a9f2478cbbf3542b49e4c8a2eb9",
      "ai_summary": "SUMMARY: This file defines FastAPI debug endpoints to expose and summarize the results and statistics of the most recent email classification batch, aiding in runtime monitoring.\n\nRELATIONSHIPS: This file serves as an API layer for debugging, imported and mounted by `mailq/api.py` into the main FastAPI application. It depends on the core classification processing logic (likely orchestrated by `api.py`) to actively update its global `last_batch_store` via the `set_last_batch` function. This enables developers to remotely monitor the outcome and performance of classification batches, providing immediate insights into system operations."
    },
    "mailq/category_manager.py": {
      "type": "python",
      "path": "mailq/category_manager.py",
      "lines": 118,
      "docstring": "Manage user-specific email categories",
      "imports": [
        "sqlite3",
        "os",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "config.default_categories.DEFAULT_CATEGORIES",
        "config.default_categories.DEFAULT_CATEGORIES"
      ],
      "internal_imports": [],
      "external_imports": [
        "sqlite3",
        "os",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "config.default_categories.DEFAULT_CATEGORIES",
        "config.default_categories.DEFAULT_CATEGORIES"
      ],
      "classes": [
        {
          "name": "CategoryManager",
          "methods": [
            "__init__",
            "_init_db",
            "get_categories",
            "_initialize_default_categories",
            "add_category",
            "get_category_names",
            "get_prompt_context"
          ],
          "method_count": 7,
          "docstring": "Manages email categories for each user"
        }
      ],
      "functions": [],
      "complexity": 7,
      "content_hash": "c7388070ff6f1b042a1f204820c120cc8e75bde485c3c5a2ba250df412d550dc",
      "ai_summary": "SUMMARY: This file manages user-specific email categories, storing them in an SQLite database and providing methods to retrieve, initialize with defaults, and add custom categories.\n\nRELATIONSHIPS: This file acts as a core data access and business logic component for email category management, used by `mailq/api.py` to expose category-related functionalities. It depends on `config/default_categories.py` to retrieve predefined category lists for initial user setup or when a user has no custom categories."
    },
    "mailq/vertex_gemini_classifier.py": {
      "type": "python",
      "path": "mailq/vertex_gemini_classifier.py",
      "lines": 521,
      "docstring": "Vertex AI Gemini - Multi-dimensional email classifier",
      "imports": [
        "vertexai",
        "vertexai.generative_models.GenerativeModel",
        "typing.Dict",
        "dotenv.load_dotenv",
        "json",
        "re",
        "mailq.feedback_manager.FeedbackManager"
      ],
      "internal_imports": [
        "mailq/feedback_manager.py"
      ],
      "external_imports": [
        "vertexai",
        "vertexai.generative_models.GenerativeModel",
        "typing.Dict",
        "dotenv.load_dotenv",
        "json",
        "re"
      ],
      "classes": [
        {
          "name": "VertexGeminiClassifier",
          "methods": [
            "__init__",
            "_build_fewshot_examples",
            "_get_static_examples",
            "classify",
            "_validate_and_normalize",
            "_extract_json",
            "_validate_result",
            "_fallback_result"
          ],
          "method_count": 8,
          "docstring": ""
        }
      ],
      "functions": [],
      "complexity": 8,
      "content_hash": "afe9dbe5e2a64a6a57c7f8d15bc84c35f98919ab3a7cf316a6888abc3c6e5083",
      "ai_summary": "SUMMARY: This file initializes a Vertex AI Gemini 2.0 Flash model to classify emails multi-dimensionally (type, domain, attention) using both static and dynamically learned few-shot examples from user feedback.\n\nRELATIONSHIPS: This file depends on `mailq.feedback_manager.py` to retrieve learned classification patterns, dynamically enhancing its few-shot examples based on user corrections. Conversely, `mailq.memory_classifier.py` imports and likely utilizes this `VertexGeminiClassifier` as a core component for performing intelligent, multi-dimensional email classification within the broader MailQ system, acting as its AI-powered classification engine."
    },
    "mailq/config/default_categories.py": {
      "type": "python",
      "path": "mailq/config/default_categories.py",
      "lines": 49,
      "docstring": "Default email categories for new users",
      "imports": [],
      "internal_imports": [],
      "external_imports": [],
      "classes": [],
      "functions": [],
      "complexity": 0,
      "content_hash": "e1d24eca56151b27c2b07f887e6763e52cf43a279ad7796eb9f74a0e25fdf7be",
      "ai_summary": "SUMMARY: This file defines a constant list of default email categories, each with a name, description, and color, intended for new user accounts within the MailQ system.\n\nRELATIONSHIPS: This file acts as a self-contained configuration data source, defining a `DEFAULT_CATEGORIES` list without any external dependencies. Other `mailq` system components, such as user creation or email processing modules, would import and utilize this list to initialize default email categories for new users. Its role is to provide a standardized, pre-defined set of initial categorization options for the application."
    },
    "mailq/config/database.py": {
      "type": "python",
      "path": "mailq/config/database.py",
      "lines": 234,
      "docstring": "Centralized database configuration\n\nProvides:\n- Single source of truth for database path\n- Connection management with proper settings\n- Schema validation\n- Test database support",
      "imports": [
        "os",
        "sqlite3",
        "pathlib.Path",
        "contextlib.contextmanager"
      ],
      "internal_imports": [],
      "external_imports": [
        "os",
        "sqlite3",
        "pathlib.Path",
        "contextlib.contextmanager"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_db_path",
          "docstring": "Get database path (environment-aware)\n\nChecks MAILQ_DB_PATH environment variable first,\nfalls back to default location."
        },
        {
          "name": "get_db_connection",
          "docstring": "Get SQLite connection with optimized settings\n\nArgs:\n    timeout: How long to wait for locks (seconds)\n\nReturns:\n    sqlite3.Connection with Row factory enabled\n\nRaises:\n    FileNotFoundError: If database doesn't exist"
        },
        {
          "name": "db_transaction",
          "docstring": "Context manager for database transactions\n\nUsage:\n    with db_transaction() as conn:\n        conn.execute(\"INSERT INTO rules ...\")\n        conn.execute(\"UPDATE categories ...\")\n    # Auto-commits on success, rolls back on error"
        },
        {
          "name": "execute_query",
          "docstring": "Execute a query and return results\n\nArgs:\n    query: SQL query string\n    params: Query parameters (tuple or dict)\n    fetch: 'all', 'one', or 'none'\n\nReturns:\n    Query results (list of Rows, single Row, or None)"
        },
        {
          "name": "validate_schema",
          "docstring": "Validate database has expected schema\n\nReturns:\n    True if valid\n\nRaises:\n    ValueError: If tables are missing"
        },
        {
          "name": "get_test_db_connection",
          "docstring": "Get connection to test database (isolated from production)\n\nUseful for unit tests - creates a separate database."
        },
        {
          "name": "init_database",
          "docstring": "Initialize database with schema (idempotent)\n\nSafe to run multiple times - uses CREATE TABLE IF NOT EXISTS."
        }
      ],
      "complexity": 7,
      "content_hash": "963424bd592225b3a02715bcb65a74c07f4f85714a0e4514ae5d029114eb316f",
      "ai_summary": "SUMMARY: This file provides a centralized SQLite database configuration, managing connections, transactions, and schema validation to serve as the core data access layer for the 'mailq' application.\n\nRELATIONSHIPS: This file serves as the foundational data access layer for the `mailq` application, providing the necessary utilities to connect to, manage, and interact with the SQLite database. Components such as `mailq/rules_manager.py` explicitly depend on it to perform all database operations, ensuring consistent connection settings, transaction handling, and schema integrity without needing to directly interact with the `sqlite3` module. It itself relies only on Python's standard library for its functionality."
    },
    "mailq/config/__init__.py": {
      "type": "python",
      "path": "mailq/config/__init__.py",
      "lines": 112,
      "docstring": "Configuration module for MailQ.\nUses the MVP v1 classification schema from Schema.json.",
      "imports": [
        "pathlib.Path"
      ],
      "internal_imports": [],
      "external_imports": [
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [],
      "complexity": 0,
      "content_hash": "d8f2c305f3626da4abd0c22b0c94a9cb40944ef354474119f2208a4064c3025e",
      "ai_summary": "SUMMARY: This file centralizes MailQ's core configuration, defining project paths, database location, enumerated email classification attributes (types, domains), and a comprehensive list of valid Gmail labels.\n\nRELATIONSHIPS: This configuration file serves as a central source of truth for MailQ's system-wide constants, making it a foundational dependency for numerous other components. Modules like database connectors, data classification logic, or any part interacting with Gmail labels will import these definitions, ensuring consistent paths, data categories, and valid label structures across the codebase. While it indirectly references `Schema.json` and `mapping.py` for its definitions, this file itself is a core utility that *provides* these structured constants to the rest of the MailQ system."
    },
    "mailq/config/settings.py": {
      "type": "python",
      "path": "mailq/config/settings.py",
      "lines": 77,
      "docstring": "Application-wide settings and environment configuration",
      "imports": [
        "os",
        "pathlib.Path"
      ],
      "internal_imports": [],
      "external_imports": [
        "os",
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "is_production",
          "docstring": "Check if running in production"
        },
        {
          "name": "is_development",
          "docstring": "Check if running in development"
        },
        {
          "name": "get_env",
          "docstring": "Get environment variable with fallback"
        }
      ],
      "complexity": 3,
      "content_hash": "ddb9ef867300f08a128dd888b98cd3bd86dc41e0798be1fa2a67ea7e9b50014b",
      "ai_summary": "SUMMARY: This file centralizes application-wide settings, environment variables, API configurations, and feature flags by reading values from environment variables or providing sensible defaults for the MailQ application.\n\nRELATIONSHIPS: This file primarily depends on the `os` module to read environment variables and `pathlib.Path` for defining project directory structures. Virtually every other component within the `mailq` application, including API endpoints, AI classification logic, feature flag checks, and logging setup, imports and utilizes these settings to configure their behavior and integrate with external services like Google Cloud or OpenAI. It acts as the core configuration provider, centralizing all configurable parameters to ensure consistent application-wide behavior across different environments."
    },
    "mailq/scripts/consolidate_databases.py": {
      "type": "python",
      "path": "mailq/scripts/consolidate_databases.py",
      "lines": 204,
      "docstring": "Consolidate all databases into mailq/data/mailq.db",
      "imports": [
        "sqlite3",
        "shutil",
        "pathlib.Path",
        "datetime.datetime"
      ],
      "internal_imports": [],
      "external_imports": [
        "sqlite3",
        "shutil",
        "pathlib.Path",
        "datetime.datetime"
      ],
      "classes": [],
      "functions": [
        {
          "name": "consolidate",
          "docstring": "Merge all databases into mailq/data/mailq.db"
        }
      ],
      "complexity": 1,
      "content_hash": "f658a32653893be4a48d6bca119cbc78a902e9099b58dead6ac123c1b209482f",
      "ai_summary": "SUMMARY: This script consolidates various Mailq system databases, including rules and learned patterns, into a single `mailq.db` file, creating a unified and initialized data store.\n\nRELATIONSHIPS: This utility script is crucial for initializing and consolidating the Mailq application's central data store, `mailq.db`, defining its foundational schema for rules, categories, feedback, and learned patterns. It depends on an existing `rules.sqlite` file for initial data population and `sqlite3` for database operations. Crucially, all other Mailq components that manage or utilize email classification, rules, categories, or feedback will depend on the `mailq.db` created and maintained by this script as their primary data source."
    },
    "mailq/scripts/inspect_databases.py": {
      "type": "python",
      "path": "mailq/scripts/inspect_databases.py",
      "lines": 114,
      "docstring": "Inspect all databases and show their contents",
      "imports": [
        "sqlite3",
        "pathlib.Path"
      ],
      "internal_imports": [],
      "external_imports": [
        "sqlite3",
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "inspect_db",
          "docstring": "Show tables and row counts for a database"
        },
        {
          "name": "main",
          "docstring": ""
        }
      ],
      "complexity": 2,
      "content_hash": "281b7c8c1a165355f789d89ac7eb0d2e797f3e5428ef61bc9a5077ff97263d30",
      "ai_summary": "SUMMARY: This Python script connects to project SQLite databases, extracts table schema, row counts, and sample data, then prints a comprehensive diagnostic report to the console.\n\nRELATIONSHIPS: This utility script critically depends on the Python `sqlite3` module for database interaction and implicitly relies on the existence and structure of SQLite database files (e.g., `mailq.db`, `rules.db`) that are created and managed by other parts of the `mailq` application. It functions as a standalone developer tool, designed for direct command-line execution to debug or monitor the application's data stores, rather than being integrated into the core `mailq` runtime logic or being depended upon by other internal components."
    },
    "scripts/fetch_emails_bulk.py": {
      "type": "python",
      "path": "scripts/fetch_emails_bulk.py",
      "lines": 196,
      "docstring": "",
      "imports": [
        "pandas",
        "os",
        "time",
        "datetime.datetime",
        "fetch_emails.fetch_unread_emails"
      ],
      "internal_imports": [],
      "external_imports": [
        "pandas",
        "os",
        "time",
        "datetime.datetime",
        "fetch_emails.fetch_unread_emails"
      ],
      "classes": [],
      "functions": [
        {
          "name": "create_bulk_dataset",
          "docstring": "One-time fetch of emails for large-scale experiments with API safety"
        },
        {
          "name": "fetch_unread_emails_safe",
          "docstring": "Safely fetch emails with retries and exponential backoff"
        },
        {
          "name": "estimate_fetch_time",
          "docstring": "Estimate how long the fetch will take"
        }
      ],
      "complexity": 3,
      "content_hash": "9bf501cff1765a99c3024b5c2ea82b82c2eee87042fcb630c315d6109ebdfcf9",
      "ai_summary": "SUMMARY: This script safely fetches a large volume of unread Gmail emails in batches, creating a CSV dataset in the `data` directory, supporting resume and refresh operations.\n\nRELATIONSHIPS: This script relies on `fetch_emails.py` (specifically `fetch_unread_emails`, though it calls an unimported `fetch_unread_emails_safe` function) to interact with the Gmail API for email retrieval, and uses `pandas` for dataset persistence and `os` for file management. Serving as a dedicated data generation utility, its primary role is to create large, API-safe email datasets stored in the `../data/` directory. Other components of the codebase, such as machine learning models or analysis scripts, would then read and consume these pre-generated datasets rather than directly importing functions from this utility."
    },
    "scripts/bootstrap_from_gold_standard.py": {
      "type": "python",
      "path": "scripts/bootstrap_from_gold_standard.py",
      "lines": 95,
      "docstring": "Bootstrap rules database from manually labeled emails",
      "imports": [
        "sys",
        "os",
        "pandas",
        "rules_engine.RulesEngine"
      ],
      "internal_imports": [],
      "external_imports": [
        "sys",
        "os",
        "pandas",
        "rules_engine.RulesEngine"
      ],
      "classes": [],
      "functions": [
        {
          "name": "bootstrap_rules",
          "docstring": ""
        }
      ],
      "complexity": 1,
      "content_hash": "90f6ebc70aa823ea3ede4b9df02cd453734a13c74ba819b4a0f1d2de476e6899",
      "ai_summary": "SUMMARY: This script populates the `rules.db` database by reading manually labeled email classifications from a CSV file and adding them as rules via the `RulesEngine` component.\n\nRELATIONSHIPS: This utility script heavily depends on the `RulesEngine` class (imported from `mailq/rules_engine.py`) to store and manage the learned rules within `data/rules.db`. It consumes a \"gold standard\" CSV dataset (`data/100_emails/email_eval_dataset.csv`), effectively bootstrapping the foundational rule set that other core components, such as an API, will then utilize for live email classification."
    },
    "scripts/fetch_emails.py": {
      "type": "python",
      "path": "scripts/fetch_emails.py",
      "lines": 86,
      "docstring": "",
      "imports": [
        "os",
        "base64",
        "json",
        "google.auth.transport.requests.Request",
        "google.oauth2.credentials.Credentials",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build"
      ],
      "internal_imports": [],
      "external_imports": [
        "os",
        "base64",
        "json",
        "google.auth.transport.requests.Request",
        "google.oauth2.credentials.Credentials",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_service",
          "docstring": "Get Gmail API service"
        },
        {
          "name": "fetch_unread_emails",
          "docstring": "Fetch recent emails from Gmail"
        }
      ],
      "complexity": 2,
      "content_hash": "dd33edb77baf456f63dd021b1e5732d1673fea764427000453de830a948a24b1",
      "ai_summary": "SUMMARY: This script authenticates with the Google Gmail API, fetches a specified count of recent emails, and extracts their subject, sender, and a snippet for further processing.\n\nRELATIONSHIPS: This file serves as an API integration layer, depending on Google's client libraries and specific `credentials/token.json` and `credentials/credentials.json` files for authentication with Gmail. Other components within the codebase would import and utilize its `fetch_unread_emails` function to retrieve raw email data, abstracting the complexities of Google API calls and user authentication. Its role is a core utility responsible for fetching email messages, acting as the primary data source from Gmail for the rest of the application."
    },
    "experiments/src/remove_priority.py": {
      "type": "python",
      "path": "experiments/src/remove_priority.py",
      "lines": 29,
      "docstring": "",
      "imports": [
        "re"
      ],
      "internal_imports": [],
      "external_imports": [
        "re"
      ],
      "classes": [],
      "functions": [
        {
          "name": "remove_priority_from_file",
          "docstring": ""
        }
      ],
      "complexity": 1,
      "content_hash": "e2ac025a96a0f4ff19541175e72d3152fc02a66d6468c46c8d333b1cf2d850b3",
      "ai_summary": "SUMMARY: This utility script modifies `experiment_runner.py` by removing all code related to \"priority\" assignment, calculation, and display, effectively stripping out a specific feature from that file.\n\nRELATIONSHIPS: This file is a standalone utility script that directly modifies `experiment_runner.py` by reading its content, applying string and regex replacements, and then overwriting the file. It depends only on Python's built-in `re` module and is not imported by any other component; instead, its role is to act as a code transformation tool, likely used during development or experimentation to reconfigure `experiment_runner.py` by disabling the priority feature."
    },
    "experiments/src/label_utils.py": {
      "type": "python",
      "path": "experiments/src/label_utils.py",
      "lines": 50,
      "docstring": "",
      "imports": [
        "fetch_emails.get_service"
      ],
      "internal_imports": [],
      "external_imports": [
        "fetch_emails.get_service"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_gmail_labels",
          "docstring": "Fetch all labels from Gmail and return a dict mapping label names to IDs."
        },
        {
          "name": "apply_label_to_email",
          "docstring": "Apply a label to an email by ID."
        },
        {
          "name": "create_gmail_label",
          "docstring": "Create a new label in Gmail, checking for duplicates first."
        }
      ],
      "complexity": 3,
      "content_hash": "74d9c9ab50534e28398522935400ed7e84ab4b69f20f1b3bd10b60b1817f7b82",
      "ai_summary": "SUMMARY: This file provides utility functions for managing Gmail labels, including fetching existing labels, creating new ones, and applying them to specific emails.\n\nRELATIONSHIPS: This file serves as a utility module for Gmail label management, depending on `fetch_emails.py` for acquiring an authenticated Gmail API service object. Its functions are likely imported and utilized by other parts of the codebase, such as email processing or categorization scripts, to programmatically interact with Gmail labels."
    },
    "experiments/src/label_setup.py": {
      "type": "python",
      "path": "experiments/src/label_setup.py",
      "lines": 75,
      "docstring": "",
      "imports": [
        "os",
        "json",
        "google.auth.transport.requests.Request",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build",
        "google.oauth2.credentials.Credentials"
      ],
      "internal_imports": [],
      "external_imports": [
        "os",
        "json",
        "google.auth.transport.requests.Request",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build",
        "google.oauth2.credentials.Credentials"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_gmail_service",
          "docstring": ""
        },
        {
          "name": "fetch_labels",
          "docstring": ""
        },
        {
          "name": "run_label_setup_wizard",
          "docstring": ""
        }
      ],
      "complexity": 3,
      "content_hash": "d70874ef4a912a5de5559e2a71c5243e59f709ff169577c97603367841a20ac3",
      "ai_summary": "SUMMARY: This script authenticates with Gmail, fetches user labels, and interactively configures AI-driven email categorization settings for selected labels, saving the schema to a JSON file.\n\nRELATIONSHIPS: This file serves as an interactive setup wizard, depending on a pre-existing `credentials.json` file for Google OAuth and generating `token.json` for persistent credentials. Its main output, `label_schema.json`, is then consumed by other AI components responsible for email classification, which utilize the defined label descriptions and importance to process and organize messages. It acts as an initial configuration entry point for the system."
    },
    "experiments/src/ai_utils.py": {
      "type": "python",
      "path": "experiments/src/ai_utils.py",
      "lines": 55,
      "docstring": "Legacy wrapper for backward compatibility.\nThis delegates to the new LLMClassifier in mailq package.\n\nTODO: Migrate all code to use LLMClassifier directly, then deprecate this file.",
      "imports": [
        "sys",
        "os",
        "llm_classifier.LLMClassifier",
        "category_manager.CategoryManager"
      ],
      "internal_imports": [],
      "external_imports": [
        "sys",
        "os",
        "llm_classifier.LLMClassifier",
        "category_manager.CategoryManager"
      ],
      "classes": [],
      "functions": [
        {
          "name": "_get_classifier",
          "docstring": "Lazy initialization of classifier"
        },
        {
          "name": "clean_text",
          "docstring": "Remove multiple invisible Unicode characters and strip whitespace."
        },
        {
          "name": "classify_email",
          "docstring": "Classify email using LLM.\n\nDEPRECATED: This is a legacy wrapper. New code should use:\n    from mailq.llm_classifier import LLMClassifier\n    classifier = LLMClassifier()\n    result = classifier.classify(subject, snippet, from_field)\n\nArgs:\n    subject: Email subject line\n    snippet: Email preview text\n    from_field: Sender email address\n\nReturns:\n    dict: {'category': str, 'confidence': int}"
        }
      ],
      "complexity": 3,
      "content_hash": "961fa64fbda1519b5c5cbd17ceda0ce3964f16a19442cf6f2c674cdc21ad04f5",
      "ai_summary": "SUMMARY: This legacy `ai_utils.py` file serves as a backward-compatible wrapper for email classification, delegating calls to the newer `mailq.LLMClassifier`, and includes a text cleaning utility, with a clear intention for deprecation.\n\nRELATIONSHIPS: This file is a deprecated compatibility layer within the `experiments` module. It dynamically adds `mailq` to the Python path to import and utilize the `LLMClassifier` and `CategoryManager` from the `mailq` package, acting as a wrapper for email classification and providing a text cleaning utility. Older components within the codebase currently depend on its `classify_email` function, but are explicitly encouraged to migrate directly to `mailq.LLMClassifier` as this file is slated for removal."
    },
    "experiments/src/compare_gemini_gpt.py": {
      "type": "python",
      "path": "experiments/src/compare_gemini_gpt.py",
      "lines": 353,
      "docstring": "Compare Gemini vs GPT-4 classification on 100 emails\nPure classification - NO reasoning to avoid chain-of-thought bias",
      "imports": [
        "sys",
        "os",
        "pandas",
        "datetime.datetime",
        "json",
        "typing.Dict",
        "typing.List",
        "asyncio",
        "memory_classifier.MemoryClassifier",
        "category_manager.CategoryManager",
        "openai",
        "sys"
      ],
      "internal_imports": [],
      "external_imports": [
        "sys",
        "os",
        "pandas",
        "datetime.datetime",
        "json",
        "typing.Dict",
        "typing.List",
        "asyncio",
        "memory_classifier.MemoryClassifier",
        "category_manager.CategoryManager",
        "openai",
        "sys"
      ],
      "classes": [],
      "functions": [
        {
          "name": "classify_with_gpt",
          "docstring": "Classify email using GPT-4 with actual confidence score"
        },
        {
          "name": "check_rule_match",
          "docstring": "Check if a rule matches an email"
        }
      ],
      "complexity": 2,
      "content_hash": "7c012789636a742726c15ddfe32c167ebe13c83daac5405df384dcf93ddde14a",
      "ai_summary": "SUMMARY: This file compares email classification performance between a local `MemoryClassifier` and GPT-4o, using a shared category system, focusing on pure classification without reasoning.\n\nRELATIONSHIPS: This file is an experimental script that depends on `MemoryClassifier` and `CategoryManager` from the `mailq` directory, utilizing their definitions for categories and one of the classifiers. It integrates the OpenAI API to provide a GPT-4o classification, benchmarking its output against the local `MemoryClassifier`. Its role is evaluative; it's not a core operational component but an assessment tool to compare different classification models."
    },
    "experiments/src/__init__.py": {
      "type": "python",
      "path": "experiments/src/__init__.py",
      "lines": 1,
      "docstring": "",
      "imports": [],
      "internal_imports": [],
      "external_imports": [],
      "classes": [],
      "functions": [],
      "complexity": 0,
      "content_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "ai_summary": "SUMMARY: This empty `__init__.py` file declares the `experiments/src` directory as a Python package, enabling its internal modules to be imported and organized within the project.\n\nRELATIONSHIPS: This file marks `experiments.src` as a Python package, enabling other parts of the codebase to import modules from it (e.g., `from experiments.src import trainer`). Any code consuming `experiments.src` modules implicitly depends on this `__init__.py` for correct package resolution. Its role is purely structural, facilitating module organization and discoverability across the entire project."
    },
    "experiments/src/fetch_emails.py": {
      "type": "python",
      "path": "experiments/src/fetch_emails.py",
      "lines": 86,
      "docstring": "",
      "imports": [
        "os",
        "base64",
        "json",
        "google.auth.transport.requests.Request",
        "google.oauth2.credentials.Credentials",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build"
      ],
      "internal_imports": [],
      "external_imports": [
        "os",
        "base64",
        "json",
        "google.auth.transport.requests.Request",
        "google.oauth2.credentials.Credentials",
        "google_auth_oauthlib.flow.InstalledAppFlow",
        "googleapiclient.discovery.build"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_service",
          "docstring": "Get Gmail API service"
        },
        {
          "name": "fetch_unread_emails",
          "docstring": "Fetch recent emails from Gmail"
        }
      ],
      "complexity": 2,
      "content_hash": "dd33edb77baf456f63dd021b1e5732d1673fea764427000453de830a948a24b1",
      "ai_summary": "SUMMARY: This file authenticates with the Google Gmail API using OAuth2 to fetch a specified number of recent emails, extracting their subject, sender, and a snippet for processing.\n\nRELATIONSHIPS: This file serves as an API client, providing a utility function to fetch email data from Gmail via OAuth2. It depends on `token.json` and `credentials.json` located at the project's root (`../../credentials/`) for authentication. Other modules, likely within the `experiments` directory, would import and call its `fetch_unread_emails` function to retrieve email data for further processing."
    },
    "extension/background.js": {
      "type": "javascript",
      "path": "extension/background.js",
      "lines": 111,
      "description": "Mailq Background Service Worker",
      "imports": [
        "./config.js",
        "./modules/auth.js",
        "./modules/gmail.js",
        "./modules/classifier.js",
        "./modules/utils.js",
        "./modules/telemetry.js"
      ],
      "internal_imports": [
        "extension/config.js",
        "extension/modules/auth.js",
        "extension/modules/gmail.js",
        "extension/modules/classifier.js",
        "extension/modules/utils.js",
        "extension/modules/telemetry.js"
      ],
      "has_async": true,
      "has_fetch": true,
      "has_export": false,
      "has_import": true,
      "content_hash": "161c24124964a9d2562ab5e3a886df6d82f8edb1bbae9884677cf22d580dbd35",
      "ai_summary": "SUMMARY: This file serves as the Mailq extension's background service worker, orchestrating the authentication, fetching, classification, and labeling of unread emails when the extension icon is clicked.\n\nRELATIONSHIPS: This file is the central orchestrator and event-driven entry point for the Mailq extension, directly depending on `config.js` for settings and various modules (`auth.js`, `gmail.js`, `classifier.js`, `utils.js`, `telemetry.js`) for core functionalities. It communicates classification results to active Gmail content scripts via `chrome.tabs.sendMessage`, which then depend on this script to receive the necessary data for display or further processing."
    },
    "extension/config.js": {
      "type": "javascript",
      "path": "extension/config.js",
      "lines": 52,
      "description": "Mailq Extension Configuration",
      "imports": [],
      "internal_imports": [],
      "has_async": false,
      "has_fetch": false,
      "has_export": true,
      "has_import": false,
      "content_hash": "d7a9c05d51c4569b5bd93d545629822898105c06520ac772e30bb459af9bed46",
      "ai_summary": "SUMMARY: This file centralizes configuration settings, API endpoints, operational limits, storage keys, and default user preferences for the Mailq browser extension.\n\nRELATIONSHIPS: This file acts as a central configuration module, providing essential constants like API endpoints, storage keys, and operational limits used by the Mailq extension. The `extension/background.js` script explicitly imports and depends on these global parameters to manage background operations and settings, while this file itself has no external dependencies."
    },
    "extension/content.js": {
      "type": "javascript",
      "path": "extension/content.js",
      "lines": 100,
      "description": "Content script for Gmail DOM monitoring",
      "imports": [],
      "internal_imports": [],
      "has_async": true,
      "has_fetch": false,
      "has_export": false,
      "has_import": true,
      "content_hash": "56524879acfb2344757248ec4926250a9772b69d4831b61e674fcc9851565ea4",
      "ai_summary": "SUMMARY: This content script injects into Gmail, monitoring email label changes, storing AI classifications received from the background script, and sending label corrections back if user-applied labels differ from predictions.\n\nRELATIONSHIPS: This file acts as the interface between the extension's background script and the Gmail DOM. It depends on the `chrome.runtime` API to receive email classifications from the background script and sends user-initiated label corrections back to it. Its role is to inject functionality directly into Gmail, observing user interactions and providing real-time feedback to the extension's core classification logic."
    },
    "extension/modules/budget.js": {
      "type": "javascript",
      "path": "extension/modules/budget.js",
      "lines": 80,
      "description": "Spend Tracking & Budget Module",
      "imports": [
        "../config.js",
        "./utils.js"
      ],
      "internal_imports": [
        "extension/modules/../config.js",
        "extension/modules/utils.js"
      ],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": true,
      "content_hash": "d09edb9c4db7cb3c55d29e76199f2cae84da8965118d2f1d2573a388371a76a2",
      "ai_summary": "SUMMARY: This file manages the extension's spend tracking and budget enforcement, allowing other parts of the application to check against a daily cap, record actual costs, and retrieve spending statistics.\n\nRELATIONSHIPS: This module is central to the extension's spend tracking and budget enforcement, importing configuration details from `config.js` for limits and storage keys, and date utilities from `utils.js`. Other extension components depend on this file's exported functions (`checkSpendBudget`, `recordSpend`, `getSpendStats`) to enforce spending limits, log costs, and display financial statistics, persisting all data via `chrome.storage.local`."
    },
    "extension/modules/telemetry.js": {
      "type": "javascript",
      "path": "extension/modules/telemetry.js",
      "lines": 120,
      "description": "Telemetry Module",
      "imports": [
        "../config.js"
      ],
      "internal_imports": [
        "extension/modules/../config.js"
      ],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": true,
      "content_hash": "477e98dc7968b912b2dcd42e8e33c96e793848f77c5261c6f6924555915b5d8f",
      "ai_summary": "SUMMARY: This file manages the collection, storage, and reporting of daily telemetry data, including email classification counts, tier distribution, and associated costs, within the browser extension.\n\nRELATIONSHIPS: This module acts as a utility layer, depending on `../config.js` for constants and dynamically importing `budget.js` for broader spend data, to manage the extension's operational metrics. It's imported by `background.js` and `classifier.js` to record email classification events and their associated costs. Its primary role is to track daily usage and provide statistical reports on the extension's activity and resource consumption."
    },
    "extension/modules/cache.js": {
      "type": "javascript",
      "path": "extension/modules/cache.js",
      "lines": 70,
      "description": "Classification Cache Module",
      "imports": [
        "../config.js"
      ],
      "internal_imports": [
        "extension/modules/../config.js"
      ],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": true,
      "content_hash": "da1be0430062b4c51b469c2c33af34d1977a72eef75eec23838c072e70d5806a",
      "ai_summary": "SUMMARY: This module manages a local browser storage cache for email classification results, allowing retrieval of cached data and updates with new entries, while enforcing expiry and size limits.\n\nRELATIONSHIPS: This utility module acts as a data caching layer. It explicitly depends on `extension/config.js` for critical settings like cache keys, expiry durations, and maximum entry limits, and relies on the `chrome.storage.local` API for its persistence. The `extension/modules/classifier.js` module imports this file, indicating it uses these caching functions to store its classification outcomes and retrieve previously processed email data, thereby reducing redundant classification requests."
    },
    "extension/modules/auth.js": {
      "type": "javascript",
      "path": "extension/modules/auth.js",
      "lines": 38,
      "description": "Gmail OAuth Authentication Module",
      "imports": [],
      "internal_imports": [],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": false,
      "content_hash": "3373cd9659969a77c7c22e90dd4c3cf1c1d34bfcf700ca41f91d55dfc6d0b541",
      "ai_summary": "SUMMARY: This module handles Gmail OAuth authentication by providing functions to programmatically retrieve and revoke user access tokens for a Chrome extension.\n\nRELATIONSHIPS: This file serves as an authentication utility, depending on the Chrome `identity` API to handle OAuth token acquisition and revocation. It is imported by `extension/background.js`, which likely uses these functions to manage the user's login state and access to Gmail services for the extension's operations."
    },
    "extension/modules/classifier.js": {
      "type": "javascript",
      "path": "extension/modules/classifier.js",
      "lines": 200,
      "description": "Email Classification Module",
      "imports": [
        "../config.js",
        "./cache.js",
        "./telemetry.js"
      ],
      "internal_imports": [
        "extension/modules/../config.js",
        "extension/modules/cache.js",
        "extension/modules/telemetry.js"
      ],
      "has_async": true,
      "has_fetch": true,
      "has_export": true,
      "has_import": true,
      "content_hash": "d528c6c5bf77fd1b6f4befa8e0056fd681892a794d7de8b184a856fe0bc40ca9",
      "ai_summary": "SUMMARY: This module classifies emails by first checking a local cache, then sending unclassified emails (deduplicated by sender) to an external API, updating the cache with new classifications, and recording telemetry.\n\nRELATIONSHIPS: This file acts as a core logic component for email classification, orchestrating interactions with an external Mailq API, a local caching mechanism (`cache.js`), and a telemetry system (`telemetry.js`). It depends on `config.js` for application-wide settings (e.g., API endpoints), and its primary `classifyEmails` function is imported and called by `extension/background.js` to perform classification tasks within the browser extension."
    },
    "extension/modules/utils.js": {
      "type": "javascript",
      "path": "extension/modules/utils.js",
      "lines": 106,
      "description": "Shared Utility Functions",
      "imports": [],
      "internal_imports": [],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": false,
      "content_hash": "43c6366f3eb0ce09b54fea29e4df6d7c9e9ff5335e37214d3d7d328aeee60544",
      "ai_summary": "SUMMARY: This file provides shared utility functions for extracting email domains, generating privacy-safe cache keys, managing user settings, and processing email lists within the extension.\n\nRELATIONSHIPS: This file functions as a core utility module, exporting various helper functions used throughout the extension. Both `extension/background.js` and `extension/modules/budget.js` depend on it, importing functions to process emails (e.g., deduplicate, expand), generate secure cache keys, and retrieve user settings stored via `chrome.storage.local`."
    },
    "extension/modules/gmail.js": {
      "type": "javascript",
      "path": "extension/modules/gmail.js",
      "lines": 224,
      "description": "Gmail API Operations Module",
      "imports": [
        "../config.js"
      ],
      "internal_imports": [
        "extension/modules/../config.js"
      ],
      "has_async": true,
      "has_fetch": true,
      "has_export": true,
      "has_import": true,
      "content_hash": "39845bdd7bdafae2c43b1ad21c710c288fe59e15d368647a3b1eb97ee841373d",
      "ai_summary": "SUMMARY: This file provides functions to interact with the Gmail API, primarily fetching and parsing a configurable number of unlabeled emails from the inbox, and managing Gmail labels.\n\nRELATIONSHIPS: This module functions as the application's dedicated Gmail API layer, importing `CONFIG` from `../config.js` to determine operational parameters like `MAX_EMAILS`. It is a critical dependency for `extension/background.js`, which utilizes its exported functions to programmatically fetch, parse, and manage user emails and labels for the extension's core logic."
    },
    "extension/modules/notifications.js": {
      "type": "javascript",
      "path": "extension/modules/notifications.js",
      "lines": 35,
      "description": "User Notifications Module",
      "imports": [],
      "internal_imports": [],
      "has_async": true,
      "has_fetch": false,
      "has_export": true,
      "has_import": true,
      "content_hash": "b03b2ef5c0ed4fcad8183c74491f2e03d5e0783d5cb8e5e2d10381683212d44f",
      "ai_summary": "SUMMARY: This file provides utility functions to display Chrome browser notifications for success, error, and daily email/spend statistics within the Mailq extension.\n\nRELATIONSHIPS: This file acts as a utility module for user feedback, abstracting the `chrome.notifications` API. It depends on the browser's `chrome.notifications` API for its core functionality and dynamically imports `getDailyReport` from `./telemetry.js` to display usage statistics. Other parts of the Mailq extension would call these exported functions (e.g., `showSuccess`, `showError`) to inform the user about operation outcomes or periodic updates."
    }
  },
  "dependencies": {
    "mailq/__init__.py": [
      "mailq/rules_engine.py",
      "mailq/memory_classifier.py"
    ],
    "mailq/rules_manager.py": [
      "mailq/config/database.py"
    ],
    "mailq/memory_classifier.py": [
      "mailq/rules_engine.py",
      "mailq/vertex_gemini_classifier.py",
      "mailq/mapper.py"
    ],
    "mailq/api.py": [
      "mailq/api_organize.py",
      "mailq/api_feedback.py",
      "mailq/memory_classifier.py",
      "mailq/api_debug.py",
      "mailq/rules_manager.py",
      "mailq/category_manager.py",
      "mailq/feedback_manager.py"
    ],
    "mailq/api_feedback.py": [
      "mailq/api_dashboard.py",
      "mailq/feedback_manager.py"
    ],
    "mailq/rules_engine.py": [
      "mailq/logger.py"
    ],
    "mailq/vertex_gemini_classifier.py": [
      "mailq/feedback_manager.py"
    ]
  },
  "js_dependencies": {
    "extension/background.js": [
      "extension/config.js",
      "extension/modules/auth.js",
      "extension/modules/gmail.js",
      "extension/modules/classifier.js",
      "extension/modules/utils.js",
      "extension/modules/telemetry.js"
    ],
    "extension/modules/budget.js": [
      "extension/modules/../config.js",
      "extension/modules/utils.js"
    ],
    "extension/modules/telemetry.js": [
      "extension/modules/../config.js"
    ],
    "extension/modules/cache.js": [
      "extension/modules/../config.js"
    ],
    "extension/modules/classifier.js": [
      "extension/modules/../config.js",
      "extension/modules/cache.js",
      "extension/modules/telemetry.js"
    ],
    "extension/modules/gmail.js": [
      "extension/modules/../config.js"
    ]
  },
  "statistics": {
    "total_files": 41,
    "python_files": 30,
    "js_files": 11,
    "total_lines": 5654,
    "total_classes": 16,
    "total_functions": 57,
    "orchestrators": [
      {
        "path": "mailq/api.py",
        "import_count": 7,
        "docstring": "FastAPI server for MailQ email classification",
        "type": "python"
      },
      {
        "path": "extension/background.js",
        "import_count": 6,
        "docstring": "",
        "type": "javascript"
      },
      {
        "path": "mailq/memory_classifier.py",
        "import_count": 3,
        "docstring": "Memory-enhanced email classifier using rules + LLM with Vertex AI",
        "type": "python"
      },
      {
        "path": "extension/modules/classifier.js",
        "import_count": 3,
        "docstring": "",
        "type": "javascript"
      }
    ],
    "core_classes": [
      {
        "path": "mailq/rules_engine.py",
        "class_name": "RulesEngine",
        "method_count": 13,
        "docstring": ""
      },
      {
        "path": "mailq/feedback_manager.py",
        "class_name": "FeedbackManager",
        "method_count": 11,
        "docstring": ""
      },
      {
        "path": "mailq/vertex_gemini_classifier.py",
        "class_name": "VertexGeminiClassifier",
        "method_count": 8,
        "docstring": ""
      },
      {
        "path": "mailq/category_manager.py",
        "class_name": "CategoryManager",
        "method_count": 7,
        "docstring": "Manages email categories for each user"
      },
      {
        "path": "mailq/memory_classifier.py",
        "class_name": "MemoryClassifier",
        "method_count": 5,
        "docstring": ""
      }
    ],
    "by_directory": {
      "mailq": {
        "files": 20,
        "lines": 3492,
        "python": 20,
        "javascript": 0
      },
      "scripts": {
        "files": 3,
        "lines": 377,
        "python": 3,
        "javascript": 0
      },
      "experiments": {
        "files": 7,
        "lines": 649,
        "python": 7,
        "javascript": 0
      },
      "extension": {
        "files": 11,
        "lines": 1136,
        "python": 0,
        "javascript": 11
      }
    }
  }
}
