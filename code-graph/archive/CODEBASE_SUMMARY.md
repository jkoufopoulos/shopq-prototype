# ðŸ¤– AI-Generated Codebase Summary

*Generated by Gemini 2.0 Flash on 2025-10-21T02:23:53.985635*

---

Okay, here's a product manager-friendly summary of the MailQ codebase:

## MailQ Codebase Summary

**1. HIGH-LEVEL OVERVIEW**

MailQ is a system designed to automatically classify and organize your emails, similar to having a smart assistant that sorts your mail into the right folders. It uses a combination of pre-defined rules and AI to understand the content of your emails and apply appropriate labels, helping you manage your inbox more efficiently.

**2. ARCHITECTURE SUMMARY**

*   **API (mailq/api.py):** The front door. It's a web server that receives email data, triggers the classification process, and returns the results.
*   **Memory Classifier (mailq/memory_classifier.py):** The brain of the operation. This component combines rules and AI to classify the email and decide which labels to apply.
*   **Rules Engine (mailq/rules_engine.py):**  Think of this as the "if/then" logic. It contains predefined rules to classify emails based on sender, keywords, etc. It also learns from manual email classification.
*   **Vertex Gemini Classifier (mailq/vertex_gemini_classifier.py):** This is the AI model (Gemini) that provides advanced email classification based on the content of the message.
*   **Mapper (mailq/mapper.py):**  This translates the classification results from the AI into specific Gmail labels that are applied to the email. It's like a translator, ensuring the labels are in the right format.
*   **Category Manager (mailq/category_manager.py):**  This component manages the different categories and labels that can be applied to emails, allowing customization for each user.
*   **Data Flow:** Emails enter through the API, the Memory Classifier first tries to classify them using the Rules Engine. If the Rules Engine can't classify, it uses the Vertex Gemini Classifier (the AI). The result is then processed by the Mapper to apply the appropriate Gmail labels, and the data is returned via the API.
*   **Key Design Pattern:**  Combination of Rules-based system and AI. This allows for quick and accurate classification for common cases (using rules) while leveraging AI for more complex or unusual emails.

**3. KEY FILES EXPLAINED**

*   **mailq/api.py:**  The "server" that receives emails for classification and sends back the results. It connects all other components. If this goes down, the whole system stops.
*   **mailq/memory_classifier.py:** This is the central classification engine. It decides whether to use a rule or the AI, and orchestrates the whole process.
*   **mailq/rules_engine.py:**  Stores and applies rules for email classification.  This allows for faster classification of common emails and adapts to user preferences by "learning".
*   **mailq/vertex_gemini_classifier.py:**  Connects to and uses the Google Vertex AI Gemini model to classify emails. This part is most responsible for "understanding" the email content.
*   **mailq/mapper.py:** Translates classification outputs into Gmail labels.  This ensures consistency and allows policy about which labels to use to be maintained in a central place.

**4. COMPONENT INTERACTIONS**

*   The `API` receives an email and passes it to the `MemoryClassifier`.
*   The `MemoryClassifier` first checks the `RulesEngine` to see if any rules apply.
*   If no rules apply, the `MemoryClassifier` sends the email to the `VertexGeminiClassifier` for AI-based classification.
*   The `VertexGeminiClassifier` returns a classification result to the `MemoryClassifier`.
*   The `MemoryClassifier` uses the `Mapper` to convert the classification result into Gmail labels.
*   The `API` returns the labels to the user/client.
*   Scripts like `check_schema.py` import configuration files directly.
*   The `RulesEngine` updates its rules database based on classifications and user corrections, creating a feedback loop.

**5. RECOMMENDATIONS FOR UPDATES**

*   **Adding a new email type:** You'd primarily focus on updating the configuration files in `mailq/config/` to add the new type to the schema. You might also need to modify the prompts used by the `VertexGeminiClassifier` to correctly identify and classify emails of this type.  Finally the mapper (mailq/mapper.py) might need updates if the classification schema requires new labels.
*   **Changing the AI model:** You'd primarily modify `mailq/vertex_gemini_classifier.py` to connect to and use the new AI model.  This would involve changes to the code that sends prompts to the model, receives responses, and parses the results.
*   **Modifying label formatting:**  You'd modify `mailq/mapper.py`.  This file is responsible for translating classification results into the final Gmail labels that are applied to the email.  This includes defining the policy around which labels get used.
