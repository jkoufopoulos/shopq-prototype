#!/bin/bash
# MailQ Quality Control Pipeline
# Analyzes digest quality, generates comparisons, and creates GitHub issues for prioritization

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

echo "ğŸ” MailQ Quality Control Pipeline"
echo "=================================="
echo ""

# Load environment variables from .env
echo "Loading environment from .env..."
source "$SCRIPT_DIR/load-env.sh" 2>/dev/null || true
echo ""

# Check prerequisites
if [ -z "$ANTHROPIC_API_KEY" ]; then
  echo "âŒ ANTHROPIC_API_KEY not set"
  echo "   Add to .env file or: export ANTHROPIC_API_KEY=your-key-here"
  exit 1
fi

if [ -z "$GITHUB_TOKEN" ]; then
  echo "âš ï¸  GITHUB_TOKEN not set - GitHub issues will not be created"
  echo "   Add to .env file or: export GITHUB_TOKEN=your-token-here"
  echo ""
fi

# Step 1: Check if there are new digest sessions to analyze
echo "ğŸ“Š Step 1: Checking for new digest sessions..."
echo ""

cd "$PROJECT_ROOT"

python3 <<EOF
import sys
sys.path.insert(0, "$PROJECT_ROOT")
sys.path.insert(0, "$SCRIPT_DIR/quality-monitor")
import quality_monitor
import json

monitor = quality_monitor.QualityMonitor()
new_sessions = monitor.get_new_sessions()

if len(new_sessions) == 0:
    print("âœ… No new sessions to analyze")
    print("")
    print("To generate a new digest session:")
    print("  1. Open Chrome with the MailQ extension")
    print("  2. Navigate to Gmail")
    print("  3. Let MailQ process some emails")
    sys.exit(0)

print(f"Found {len(new_sessions)} new sessions:")
for session in new_sessions[:5]:
    print(f"  - {session['session_id']}")
print("")
EOF

# Step 2: Run quality monitor analysis
echo "ğŸ¤– Step 2: Running Claude analysis on digest sessions..."
echo ""

python3 "$SCRIPT_DIR/quality-monitor/quality_monitor.py" --analyze-now

if [ $? -ne 0 ]; then
  echo "âŒ Quality analysis failed"
  exit 1
fi

echo ""

# Step 3: Check if quality_logs directory exists for digest comparison
echo "ğŸ“ˆ Step 3: Checking for digest quality logs..."
echo ""

if [ -d "$PROJECT_ROOT/quality_logs" ] && [ "$(ls -A "$PROJECT_ROOT/quality_logs"/input_emails_*.json 2>/dev/null)" ]; then
  echo "âœ… Found digest quality logs"
  echo ""

  echo "ğŸ“Š Generating digest comparison (ACTUAL vs IDEAL)..."
  echo ""

  cd "$PROJECT_ROOT"
  python3 "$SCRIPT_DIR/generate_digest_comparison.py"

  if [ $? -eq 0 ]; then
    # Find the latest comparison file
    LATEST_COMPARISON=$(ls -t "$PROJECT_ROOT/quality_logs"/comparison_*.md 2>/dev/null | head -1)

    if [ -n "$LATEST_COMPARISON" ]; then
      echo ""
      echo "âœ… Digest comparison generated: $LATEST_COMPARISON"
      echo ""
      echo "ğŸ“ Review the comparison to identify gaps:"
      echo "   open $LATEST_COMPARISON"
      echo ""
    fi
  else
    echo "âš ï¸  Digest comparison generation failed (non-critical)"
  fi
else
  echo "â„¹ï¸  No digest quality logs found - skipping comparison"
  echo "   To enable: Backend must save input_emails_*.json and actual_digest_*.html"
  echo ""
fi

# Step 4: Generate GitHub issues from quality database
echo "ğŸ™ Step 4: Creating GitHub issues for quality problems..."
echo ""

if [ -n "$GITHUB_TOKEN" ]; then
  # Check if there are new issues since last run
  DB_PATH="$SCRIPT_DIR/quality-monitor/quality_monitor.db"

  NEW_ISSUES=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM quality_issues WHERE github_issue_url IS NULL AND severity IN ('high', 'medium');")

  if [ "$NEW_ISSUES" -gt 0 ]; then
    echo "Found $NEW_ISSUES new issues to create on GitHub"
    echo ""

    # Generate issue creation script dynamically
    python3 <<EOF
import sqlite3
import json

db_path = "$DB_PATH"
conn = sqlite3.connect(db_path)
cursor = conn.cursor()

cursor.execute("""
  SELECT id, severity, pattern, evidence, root_cause, suggested_fix, created_at
  FROM quality_issues
  WHERE github_issue_url IS NULL
    AND severity IN ('high', 'medium')
  ORDER BY
    CASE severity
      WHEN 'high' THEN 1
      WHEN 'medium' THEN 2
      ELSE 3
    END,
    created_at DESC
""")

issues = cursor.fetchall()
conn.close()

SEVERITY_EMOJI = {"high": "ğŸ”´", "medium": "ğŸŸ¡", "low": "âšª"}
REPO = "jkoufopoulos/mailq-prototype"

for issue_id, severity, pattern, evidence, root_cause, suggested_fix, created_at in issues:
    emoji = SEVERITY_EMOJI.get(severity, "âšª")

    # Truncate title if too long (GitHub limit is 256)
    title = f"{emoji} [Quality] {pattern}"
    if len(title) > 70:
        title = title[:67] + "..."

    print(f'Creating: {title}')

    # Create GitHub issue
    body = f"""## Issue Pattern
{pattern}

## Evidence
{evidence}

## Root Cause
{root_cause}

## Suggested Fix
{suggested_fix}

---
*Auto-generated by Quality Monitor*
*Severity: {severity}*
*Created: {created_at}*
"""

    # Escape for shell
    body_json = json.dumps(body)
    title_json = json.dumps(title)

    print(f'curl -s -X POST \\')
    print(f'  -H "Authorization: token $GITHUB_TOKEN" \\')
    print(f'  -H "Accept: application/vnd.github.v3+json" \\')
    print(f'  -H "Content-Type: application/json" \\')
    print(f'  https://api.github.com/repos/{REPO}/issues \\')
    print(f'  -d @- << \'ISSUE_JSON\' | jq -r \'.html_url // .message\'')
    print('{')
    print(f'  "title": {title_json},')
    print(f'  "body": {body_json},')
    print(f'  "labels": ["quality", "severity-{severity}", "auto-generated"]')
    print('}')
    print('ISSUE_JSON')
    print()
    print('echo ""')
    print()
EOF
  else
    echo "âœ… No new issues to create (all issues already on GitHub)"
  fi
else
  echo "âš ï¸  Skipping GitHub issue creation (GITHUB_TOKEN not set)"
fi

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… Quality Control Pipeline Complete!"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

# Step 5: Summary report
echo "ğŸ“‹ Summary Report"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

DB_PATH="$SCRIPT_DIR/quality-monitor/quality_monitor.db"

echo ""
echo "Quality Issues by Severity:"
sqlite3 "$DB_PATH" "
  SELECT
    severity,
    COUNT(*) as count,
    SUM(CASE WHEN github_issue_url IS NOT NULL THEN 1 ELSE 0 END) as on_github
  FROM quality_issues
  GROUP BY severity
  ORDER BY
    CASE severity
      WHEN 'high' THEN 1
      WHEN 'medium' THEN 2
      ELSE 3
    END
" | awk -F'|' '{
  emoji = ($1 == "high" ? "ğŸ”´" : ($1 == "medium" ? "ğŸŸ¡" : "âšª"));
  printf "  %s %-10s: %2d total, %2d on GitHub\n", emoji, $1, $2, $3
}'

echo ""
echo "Recent Issues:"
sqlite3 "$DB_PATH" "
  SELECT
    severity,
    pattern,
    SUBSTR(created_at, 1, 10) as date
  FROM quality_issues
  ORDER BY created_at DESC
  LIMIT 5
" | awk -F'|' '{
  emoji = ($1 == "high" ? "ğŸ”´" : ($1 == "medium" ? "ğŸŸ¡" : "âšª"));
  pattern = substr($2, 1, 60);
  if (length($2) > 60) pattern = pattern "...";
  printf "  %s [%s] %s (%s)\n", emoji, $1, pattern, $3
}'

echo ""
echo "Sessions Analyzed:"
sqlite3 "$DB_PATH" "
  SELECT COUNT(*) FROM analyzed_sessions
" | awk '{printf "  Total: %d sessions\n", $1}'

sqlite3 "$DB_PATH" "
  SELECT
    SUBSTR(analyzed_at, 1, 10) as date,
    COUNT(*) as count
  FROM analyzed_sessions
  GROUP BY date
  ORDER BY date DESC
  LIMIT 3
" | awk -F'|' '{printf "  %s: %d sessions\n", $1, $2}'

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "Next Steps:"
echo "  1. Review GitHub issues: gh issue list --label quality"
echo "  2. Prioritize and fix high-severity issues first"
echo "  3. Re-run pipeline after fixes: ./scripts/run-quality-pipeline.sh"
echo "  4. Monitor digest quality: open quality_logs/comparison_*.md"
echo ""
